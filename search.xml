<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ExoPlayer 中 MediaController 的定制]]></title>
      <url>http://artharyoung.github.io/2016/08/26/2016-8-26/</url>
      <content type="html"><![CDATA[<p>在播放器的组件中，MediaController 主要负责用户在播放中的界面交互，比如进度条的显示与操作、快进、快退、上一个、下一个等。也可以根据需求定制一些自己的操作需求，比如播放器中输入的是直播（或者HLS）的 m3u8 的视频流。那么可能需要添加刷新界面的操作按钮。这一篇主要梳理一下自己在开发 <a href="https://github.com/AndroidTips/MDVideo" target="_blank" rel="external">MDVideo</a>过程中遇到的问题，然后以自己所理解的方式阐述一下  MediaController 到底是什么东西。如有错误，还请指正。<br><a id="more"></a></p>
<h2 id="ExoPlayer-Demo-中的-MediaController"><a href="#ExoPlayer-Demo-中的-MediaController" class="headerlink" title="ExoPlayer Demo 中的 MediaController"></a>ExoPlayer Demo 中的 MediaController</h2><p>在<a href="https://github.com/google/ExoPlayer/tree/release-v1/demo" target="_blank" rel="external">demo</a>中，并没有哪个 class 跟 MediaController 名字相关联，因为 demo 中根本没有去写一个 <a href="https://developer.android.com/reference/android/widget/MediaController.html" target="_blank" rel="external">MediaController</a> 而是使用系统自带的。那么我们就抓着系统的源码来看看他究竟干了什么，然后再把系统自带的这个干掉，照着样子写一个来实现自己的需求。</p>
<p>我们在<a href="https://github.com/google/ExoPlayer/blob/release-v1/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java" target="_blank" rel="external">PlayerActivity</a>中找到 MediaController 然后查找到调用的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setAnchorView</span><span class="params">(View rootView)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setMediaPlayer</span><span class="params">(MediaPlayerControl player)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isShowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>全部写到一个抽象类中，方便下一步定制。接下来再看看 MediaController 中都是怎么实现的。</p>
<p>MediaController 继承自 FrameLayout 。在构造方法中，调用 initFloatingWindow 进行 View 初始化构造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFloatingWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">      mWindow = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">      mWindow.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      mWindow.requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">      mDecor = mWindow.getDecorView();</span><br><span class="line">      mDecor.setOnTouchListener(mTouchListener);</span><br><span class="line">      mWindow.setContentView(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.setBackgroundDrawableResource(android.R.color.transparent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// While the media controller is up, the volume control keys should</span></span><br><span class="line">      <span class="comment">// affect the media stream type</span></span><br><span class="line">      mWindow.setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br><span class="line"></span><br><span class="line">      setFocusable(<span class="keyword">true</span>);</span><br><span class="line">      setFocusableInTouchMode(<span class="keyword">true</span>);</span><br><span class="line">      setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">      requestFocus();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这一步，我们发现。MediaController 首先获取了系统的 WindowManager 对象。然后 new 了一个 PhoneWindow 并将系统的 WindowManager 传给它。然后通过 getDecorView 获取当前界面最底层的 View 然后进行一些add remove等操作来实现播放控制布局的移除与添加。将 MediaController 中的代码复制出来新建一个类，会发现一些错误都好解决，唯独 PhoneWindow 这个对象是无法获取到的。所以起初偷懒打算直接代码 copy 过来，改改layout的想法行不通。（这里是否直接替换了Activity的PhoneWindow我其实没搞清楚，我只知道Activity会在onCreate中去生成window,这里在获取windowManager后已经可以操作悬浮窗了为何还要 new 一个 phoneWindow）</p>
<h2 id="MediaController-的自定义"><a href="#MediaController-的自定义" class="headerlink" title="MediaController 的自定义"></a>MediaController 的自定义</h2><p>重新认识一下 MediaController ，其实就是悬浮的 View 然后响应了播放控制的一些操作。所以我们把之前提取到抽象类的方法实现就可以了。然后在自定义的 MediaController 里构造自己的布局，使用PopupWindow也是可以的。先理一下每个方法的作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setAnchorView</span><span class="params">(View rootView)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在 PlayerActivity 中调用，将父布局传入，主要的作用：</p>
<ul>
<li>为了添加事件监听，处理交互操作。</li>
<li>确定显示位置（使用 PopupWindow 的话）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setMediaPlayer</span><span class="params">(MediaPlayerControl player)</span></span>;</span><br></pre></td></tr></table></figure>
<p>播放控制回调，这里我们继续使用系统 MediaController 中的 MediaPlayerControl 代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayerControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">getDuration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">getCurrentPosition</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>    <span class="title">seekTo</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPlaying</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">getBufferPercentage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canPause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canSeekBackward</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">canSeekForward</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Get the audio session id for the player used by this VideoView. This can be used to</span><br><span class="line">     * apply audio effects to the audio track of a video.</span><br><span class="line">     * <span class="doctag">@return</span> The audio session, or 0 if there was an error.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>     <span class="title">getAudioSessionId</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说实话，这部分代码的调用看着有点别扭。因为 ExoPlayer 中使用的就是系统的 MediaPlayerControl ，可能是因为 demo 中使用 MediaController 缘故。我觉得这个接口应该由 ExoPlayer 自己去定义，这样才不会跟系统的接口搅到一起去，也方便用户扩展。可惜 demo 中没有自定义MediaController,所以导致只能用系统的。话又说回来，这个接口已经能满足需求了，没必要重复造轮子，没准哪天 ExoPlayer 直接整合到系统源代码里了，这个问题也就不存在了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isShowing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这四个方法用来控制悬浮窗的显示与隐藏，判断显示状态，设置是否可操作等。</p>
<p>理清以上关系以后，具体的实现就清晰了，我写了一个本地视频播放控制的 MediaController ,具体可以看<a href="https://github.com/AndroidTips/MDVideo/blob/master/app/src/main/java/com/studyjams/mdvideo/PlayerModule/MediaController/ExtractorMediaController.java" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ExoPlayer Demo 媒体类型参数]]></title>
      <url>http://artharyoung.github.io/2016/07/09/2016-7-9/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/google/ExoPlayer" target="_blank" rel="external">ExoPlayer</a>是Google开源的播放器，可以算是<a href="https://developer.android.com/reference/android/media/MediaPlayer.html" target="_blank" rel="external">MediaPlayer</a>的扩展版本吧,因为跟一些小伙伴发起了一个播放器开发的项目，所以接下来打算把学到的东西都写下来。一来，可以方便和其他小伙伴交流，二来，也方便以后自己复习。碍于自己Android知识水平有限，如有错误还请大家多多指教。</p>
<ul>
<li>注：ExoPlayer版本 r1.5.9，单独分离出来的<a href="https://github.com/artharyoung/ExoPlayerDemo" target="_blank" rel="external">ExoPlayerDemo</a><a id="more"></a>
</li>
</ul>
<p>在Demo中可以看到，流媒体播放的请求都是以Intent的形式，封装一个<a href="https://github.com/artharyoung/ExoPlayerDemo/blob/master/app/src/main/java/com/artharyoung/exoplayerdemo/Samples.java" target="_blank" rel="external">Sample</a>去拉起一个播放页面的Activity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent mpdIntent = <span class="keyword">new</span> Intent(mContext, PlayerActivity.class)</span><br><span class="line">                .setData(Uri.parse(sample.uri))</span><br><span class="line">                .putExtra(PlayerActivity.CONTENT_ID_EXTRA, sample.contentId)</span><br><span class="line">                .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type)</span><br><span class="line">                .putExtra(PlayerActivity.PROVIDER_EXTRA, sample.provider);</span><br><span class="line">        mContext.startActivity(mpdIntent);</span><br></pre></td></tr></table></figure></p>
<p>而在Sample的构造方法中，需要传入媒体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sample[] CNTV_DASH = <span class="keyword">new</span> Sample[]&#123;</span><br><span class="line">            <span class="keyword">new</span> Sample(<span class="string">"CCTV-1HD"</span>,</span><br><span class="line">            <span class="string">"http://vod.cdn4.cmvideo.cn/envivo_v/HD/cctv1/450/01.m3u8"</span>, Util.TYPE_HLS),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>同时在PlayerActivity中可以看到，根据不同的流媒体类型会回调不同的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RendererBuilder <span class="title">getRendererBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String userAgent = Util.getUserAgent(<span class="keyword">this</span>, <span class="string">"PlayerActivity"</span>);</span><br><span class="line">        <span class="keyword">switch</span> (contentType) &#123;</span><br><span class="line">            <span class="keyword">case</span> Util.TYPE_SS:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SmoothStreamingRendererBuilder(<span class="keyword">this</span>, userAgent,</span><br><span class="line">                        contentUri.toString(),</span><br><span class="line">                        <span class="keyword">new</span> SmoothStreamingTestMediaDrmCallback());</span><br><span class="line">            <span class="keyword">case</span> Util.TYPE_DASH:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DashRendererBuilder(<span class="keyword">this</span>, userAgent, contentUri.toString(),</span><br><span class="line">                        <span class="keyword">new</span> WidevineTestMediaDrmCallback(contentId, provider));</span><br><span class="line">            <span class="keyword">case</span> Util.TYPE_HLS:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HlsRendererBuilder(<span class="keyword">this</span>, userAgent, contentUri.toString());</span><br><span class="line">            <span class="keyword">case</span> Util.TYPE_OTHER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExtractorRendererBuilder(<span class="keyword">this</span>, userAgent, contentUri);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported type: "</span> + contentType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着前面的线索，查找Util类中的类型参数，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Value returned by &#123;<span class="doctag">@link</span> #inferContentType(String)&#125; for DASH manifests.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DASH = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Value returned by &#123;<span class="doctag">@link</span> #inferContentType(String)&#125; for Smooth Streaming manifests.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Value returned by &#123;<span class="doctag">@link</span> #inferContentType(String)&#125; for HLS manifests.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_HLS = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Value returned by &#123;<span class="doctag">@link</span> #inferContentType(String)&#125; for files other than DASH,</span><br><span class="line">   * HLS or Smooth Streaming manifests.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_OTHER = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>看到这里，直观的反应是这四个参数代表不同的流媒体协议。之前都流媒体的协议并不是很了解，于是开始搜索。找到了部分跟协议相关的知识，比如<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E9%81%A9%E6%80%A7%E4%B8%B2%E6%B5%81" target="_blank" rel="external">自适性串流</a>。阅读后对流媒体协议有了初步的了解，但感觉还是跟给出的四个类型对不上。终于注意到 inferContentType(String) 这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Makes a best guess to infer the type from a file name.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> fileName Name of the file. It can include the path of the file.</span><br><span class="line">   * <span class="doctag">@return</span> One of &#123;<span class="doctag">@link</span> #TYPE_DASH&#125;, &#123;<span class="doctag">@link</span> #TYPE_SS&#125;, &#123;<span class="doctag">@link</span> #TYPE_HLS&#125; or</span><br><span class="line">   * &#123;<span class="doctag">@link</span> #TYPE_OTHER&#125;.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inferContentType</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fileName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE_OTHER;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".mpd"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE_DASH;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".ism"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE_SS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".m3u8"</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE_HLS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> TYPE_OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看inferContentType的调用会发现，在传入的Sample没有设置类型的时候，会调用该方法检测Uri的后缀，然后根据后缀进行如上分类，并不是代表某一个协议的意思。我用一个MP4格式的本地视频，以TYPE_SS的类型传入，发现也是能播放的。猜测这个类型参数可能在播放时会进行某些优化。只好在接下来的学习中再去解决自己的疑惑了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 学习笔记（二）]]></title>
      <url>http://artharyoung.github.io/2016/07/04/2016-7-4/</url>
      <content type="html"><![CDATA[<img src="/images/111_13.png">
<p>Git存储快照流<br><a id="more"></a></p>
<h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><ul>
<li><p>当进行commit操作时，git会保存一个提交对象（commit object）。改提交对象会包含一个指向暂存内容快照的指针，该对象还包含提交信息和指向父对象的指针</p>
</li>
<li><p>git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是master。在多次提交操作后，你其实已经有一个指向最后那个提交对象的master分支。他会在每次提交操作中自动向前移动。</p>
</li>
<li><p>git 的“master”分支并不是一个特殊分支。它跟其它分支完全没有区别。之所以几乎每一个仓库都有master分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。</p>
</li>
</ul>
<h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><p>git branch testing<br>这会在当前所在的提交对象上创建一个指针</p>
<img src="/images/111_12.png">
<p>git有一个名为HEAD的特殊指针。指向当前所在的本地分支。git branch仅仅会创建一个新分支，并不会切换到新分支去。</p>
<img src="/images/111_11.png">
<p>可以使用git log命令查看各个分支当前所指的对象，使用 –decorate选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate</span><br></pre></td></tr></table></figure></p>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p>使用git checkout命令切换分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure></p>
<p>这样HEAD就指向testing分支了</p>
<img src="/images/111_10.png">
<p>在testing分支上再提交一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;made a change&quot;</span><br></pre></td></tr></table></figure></p>
<img src="/images/111_9.png">
<p>testing分支向前移动，但是master 分支却没有，它仍然指向运行git checkout时所指的对象。切换回master分支查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></p>
<img src="/images/111_8.png">
<p>这条命令做了两件事。一是使HEAD指向master分支，二是将工作目录恢复成master分支所指向的快照内容。项目将始于一个较旧的版本。从本质上讲，这就是忽略testing分支所做的修改，以便于向另一个方向进行开发。</p>
<p>分支切换会改变工作目录中的文件，在切换分支时，工作目录中的文件会被改变。如果是切换到一个较旧的分支，工作目录会恢复到该分支最后一次提交时的样子。如果git 不能干净利索地完成这个任务，它将禁止切换分支。</p>
<p>在master分支上再提交一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;made other change&quot;</span><br></pre></td></tr></table></figure></p>
<img src="/images/111_1.png">
<p>现在，这个项目的提交历史已经产生了分叉，可以使用git log 命令查看分叉历史。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure></p>
<p>它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b iss53</span><br></pre></td></tr></table></figure>
<p>这条指令相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure></p>
<p>创建一个分支同时切换到那个分支上，在切换分支时，要留意工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止<br>git切换到该分支。最好在切换分支前，保持一个干净的状态。</p>
<p>修改完成后，使用下列指令来合并分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge iss53</span><br></pre></td></tr></table></figure></p>
<p>合并后，使用git status指令来查看因冲突而不能合并的文件，在手动处理冲突后，再提交一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;merge&quot;</span><br></pre></td></tr></table></figure></p>
<p>合并完成，iss53分支已经不再需要了，可以使用-d选项来删除分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d iss53</span><br></pre></td></tr></table></figure></p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看当前分支列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看每个分支的最后一次提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--merged</span><br><span class="line">--no-merged</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两个选项用来过滤和查看已合并到当前分支的分支和未合并到当前分支的分支<br>然后对已合并的分支进行删除。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 学习笔记（一）]]></title>
      <url>http://artharyoung.github.io/2016/07/02/2016-7-2/</url>
      <content type="html"><![CDATA[<p>话说使用Git也有三个多月了，之前一直在用SVN管理代码。重复的敲了这么久的commit&amp;add指令，其实并没有真正理解其中的含义，系统的学习和整理一些知识，才能构建自己的知识体系。于是找来官方的文档，打算好好看一下。其实相关的学习在一周前已经完成了，一直没有整理出来。本篇的知识主要来自<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Pro Git</a>的前两章，”分支”我打算单独记一篇，毕竟是Git的杀手锏。<br><a id="more"></a></p>
<h2 id="配置和初始化"><a href="#配置和初始化" class="headerlink" title="配置和初始化"></a>配置和初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  配置提交的用户名</span><br><span class="line">git config --global user.email 配置提交的邮箱地址</span><br></pre></td></tr></table></figure>
<p>–global选项用来配置全局设置，用户和邮箱设置好后，在配置好基本的信息后，在每一次提交时，系统都会自动的带上作者信息。</p>
<p>完成配置后，选择需要进行版本管控的文件目录执行下列指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init 创建.git子目录。.git可以用来跟踪文件版本信息。</span><br></pre></td></tr></table></figure>
<h2 id="文件的生命周期"><a href="#文件的生命周期" class="headerlink" title="文件的生命周期"></a>文件的生命周期</h2><img src="/images/2016-7-2.png">
<blockquote>
<p>你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p>
</blockquote>
<h2 id="添加文件与克隆"><a href="#添加文件与克隆" class="headerlink" title="添加文件与克隆"></a>添加文件与克隆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add *.c 添加后缀为.c的文件</span><br><span class="line">git add LICENSE 添加版权信息</span><br><span class="line">git commit -m &quot;msg&quot;</span><br><span class="line"></span><br><span class="line">git clone [url] 克隆远程服务器上几乎所有的文件以及过往的历史版本。</span><br><span class="line">git clone [url] [filename] 自定义克隆到本地仓库的名字。</span><br></pre></td></tr></table></figure>
<h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status 查看文件的状态</span><br><span class="line">git status -s 得到状态的简写状态</span><br><span class="line">git status --short</span><br></pre></td></tr></table></figure>
<p>几种状态：</p>
<ul>
<li>nothing to commit, working directory clean ： 所有更改均已提交</li>
<li>Untracked files: 未被跟踪文件</li>
<li>Changes to be committed: 使用add添加未跟踪文件后还未commit</li>
<li>Changes not staged for commit: 已跟踪文件修改后未commit</li>
</ul>
<h2 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件 .gitignore"></a>忽略文件 .gitignore</h2><p>*.[oa] 忽略所有以.o和.a结尾的文件。 一般这类对象文件和存档文件都是编译过程中出现的。<br>*~ 忽略所有~结尾的文件  许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。<br>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<h2 id="分析文件差异"><a href="#分析文件差异" class="headerlink" title="分析文件差异"></a>分析文件差异</h2><p>git diff  当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？</p>
<p>与git status的区别： 通过文件补丁的格式显示具体哪些行发生了改变</p>
<p>git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因</p>
<p>git difftool 分析文件差异，可视化工具</p>
<h2 id="提交和删除"><a href="#提交和删除" class="headerlink" title="提交和删除"></a>提交和删除</h2><p>git commit 这种方式会启动文本编辑器以便于编辑本次提交说明。</p>
<p>可以使用git commit -m “msg”的方式来一起提交</p>
<p>git add 用来将文件添加到缓存区，便于详细的编辑提交信息。但有时过于繁琐，可以使用</p>
<p>git commit -a -m “msg”来跳过缓存区使用缓存区</p>
<p>git rm README.md 移除文件，如果删除前已经使用git add 放到了暂存区。必须使用强制删除选项git rm -f (force)这样的数据不能被git恢复</p>
<p>另一种情况，当不希望文件被追踪。但仍然希望保留在当前目录，如果忘记添加到.gitignore不小心把一大堆 .a 文件添加到了暂存区。</p>
<p>使用–cached 选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached README</span><br><span class="line"></span><br><span class="line">git rm log/\*.log删除log/目录下，以.log为扩展名的所有文件</span><br><span class="line">git rm \*~删除以~结尾的所有文件</span><br><span class="line"></span><br><span class="line">git mv README.md README对文件进行改名相当于执行了以下三条指令：</span><br><span class="line">mv README.md README</span><br><span class="line">git rm README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure></p>
<h2 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log 查看提交历史</span><br><span class="line">git log -p -2 查看最近两次提交的差异历史</span><br></pre></td></tr></table></figure>
<p>-p 选项用来显示每次提交的内容差异</p>
<p>-2 用来仅显示最近两次提交</p>
<p>这个选项适用于查看团队其他成员提交代码时的更改，也可以使用下面的指令来查看简要信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br><span class="line"></span><br><span class="line">git log --pretty=oneline 将每个提交信息放在一行显示，还有short full fuller可以用</span><br><span class="line"></span><br><span class="line">git log --pretty=format:&quot;%h - %an :%s&quot; 按格式显示提交信息</span><br></pre></td></tr></table></figure></p>
<h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v 查看配置的远程仓库列表</span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;添加一个远程git仓库，同时指定一个方便检索的url</span><br></pre></td></tr></table></figure>
<h2 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>如果你使用clone命令克隆了一个仓库，命令会自动将其添加为远程默认仓库并默认以“origin”为简写。git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。fetch命令会将数据拉取到你的本地仓库，他并不会自动合并或修改你当前的工作，当准备好时你必须手动将其合并入你的工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull抓取然后合并远程分支到当前分支</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，git clone 命令会自动设置本地master分支跟踪克隆的远程仓库的master分支（或不管是什么名字的默认分支）运行git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>推送成功的前提是服务器仓库没有更新，否则需要先git pull 拉取合并后再推送才能成功。</p>
<h2 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show origin</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old name&gt;&lt;new name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="移除远程仓库"><a href="#移除远程仓库" class="headerlink" title="移除远程仓库"></a>移除远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<h2 id="列出某一系列的标签"><a href="#列出某一系列的标签" class="headerlink" title="列出某一系列的标签"></a>列出某一系列的标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &quot;v1.8.5*&quot; 使用通配符查看V1.8.5系列</span><br></pre></td></tr></table></figure>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &quot;msg&quot; 创建附注标签</span><br><span class="line">git show v1.4 查看标签和对应的信息</span><br><span class="line"></span><br><span class="line">git tag v1.4 轻量标签</span><br></pre></td></tr></table></figure>
<h2 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline 列出提交历史</span><br><span class="line">git tag -a v1.4 9fc1b02 需要在末尾指定校验和或(9fc1b02 )部分检验和</span><br></pre></td></tr></table></figure>
<h2 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h2><p>默认情况下，git push命令并不会传送标签到远程服务器仓库上，在创建完标签后必须显示的推送标签到共享服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin [tagname] git push origin v1.5</span><br></pre></td></tr></table></figure></p>
<p>也可以使用–tags选项一次推送很多标签，这将会把所有不在远程仓库服务器上的标签全部传送到那里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p>
<h2 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h2><p>在git中并不能真的检出一个标签，因为他们不能像分支一样来回移动。如果想要工作目录与仓库中特定的标签版本完全一样，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [branch name]  [tag name]</span><br><span class="line">git checkout -b version2 v2.0.0</span><br></pre></td></tr></table></figure></p>
<p>如果在这之后又进行了一次提交，version2分支会因为改动向前移动，version2会与标签v2.0.0不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程方法学第三课学习笔记]]></title>
      <url>http://artharyoung.github.io/2016/06/26/karel-and-java/</url>
      <content type="html"><![CDATA[<h2 id="off-by-one-bug-差一错误"><a href="#off-by-one-bug-差一错误" class="headerlink" title="off-by-one bug 差一错误"></a>off-by-one bug 差一错误</h2><p>差一错误（英语：Off-by-one error，缩写OBOE）是在计数时由于边界条件判断失误导致结果多了一或少了一的错误，通常指计算机编程中循环多了一次或者少了一次的程序错误，属于逻辑错误的一种。比如，程序员在循环中进行比较的时候，本该使用“小于等于”，但却使用了“小于”，或者是程序员没有考虑到一个序列是从0而不是1开始（许多程序语言的数组下标都是这样）。在数学领域，此错误也时有发生。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B7%AE%E4%B8%80%E9%94%99%E8%AF%AF" target="_blank" rel="external">wiki</a><br><a id="more"></a></p>
<h2 id="top-down-design-自顶向下设计"><a href="#top-down-design-自顶向下设计" class="headerlink" title="top-down design 自顶向下设计"></a>top-down design 自顶向下设计</h2><p>1969年，Wirth提出采用“自顶向下逐步求精、分而治之”的原则进行大型程序的设计。其基本思想是：从欲求解的原问题出发，运用科学抽象的方法，把它分解成若干相对独立的小问题，依次细化，直至各个小问题获得解决为止。</p>
<h3 id="分解的原则"><a href="#分解的原则" class="headerlink" title="分解的原则"></a>分解的原则</h3><ul>
<li>程序可以解决一个问题，这个问题可以是高阶的</li>
<li>大部分所写的方法应该在1~15行之间。这样会改变本来的设计观念。</li>
<li>good names 名字应该描述这个方法是干什么的，解决了什么问题</li>
<li>注释，注释能够更好的说明方法是干什么的。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[APP Bar 的使用]]></title>
      <url>http://artharyoung.github.io/2016/06/16/2016-6-16/</url>
      <content type="html"><![CDATA[<p>最近在自己的项目<a href="https://github.com/AndroidTips/MDVideo" target="_blank" rel="external">MDVideo</a>中添加了半透明的 StatusBar 效果，索性把官方文档中关于这一部分的讲解总结一下，加强一下这一块的记忆。之前做了一年半的 TV 应用开发，由于交互上只处理 OnKey 的事件，所以应用基本都是采用 FullScreen 样式。并且由于当时使用的 Eclipse对 support V7 包的支持完全令人无语，导致这一块细节的了解还是比较陌生的。</p>
<p>Google 在 Android 5.0 引入 Material Design，同时很多 ActionBar 的方法被弃用了，通过在 Appcombat V7 包中添加 ToolBar 来替代原有的 ActionBar。由于是引用 Library, 这在版本兼容上避免了很多问题。ToolBar 之前，在 Android 3.0开始，ActionBar包含于 Theme.Holo 主题中，本篇会引用 ActionBar 的一些介绍,以便于了解 ActionBar 在 APP 中的作用，ToolBar 的设计理念与它是一样的，但不赘述怎么使用，因为已经过时了。</p>
<a id="more"></a>
<h2 id="添加ToolBar"><a href="#添加ToolBar" class="headerlink" title="添加ToolBar"></a>添加ToolBar</h2><blockquote>
<p>Action bar 最基本的形式，就是为 Activity 显示标题，并且在标题左边显示一个 app icon。即使在这样简单的形式下，action bar对于所有的 activity 来说是十分有用的。它告知用户他们当前所处的位置，并为你的 app 维护了持续的同一标识。</p>
</blockquote>
<p>在xml文件中添加ToolBar:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">            android:id=<span class="string">"@+id/toolbar"</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:fitsSystemWindows=<span class="string">"true"</span></span><br><span class="line">            android:background=<span class="string">"?attr/colorPrimary"</span></span><br><span class="line">            app:popupTheme=<span class="string">"@style/AppTheme.PopupOverlay"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在AppCompatActivity里设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure></p>
<p>tips：这里使用的style都是Theme.AppCompat主题族。</p>
<h2 id="在-ToolBar-中添加item"><a href="#在-ToolBar-中添加item" class="headerlink" title="在 ToolBar 中添加item"></a>在 ToolBar 中添加item</h2><blockquote>
<p>Action bar 允许我们为当前环境下最重要的操作添加按钮。那些直接出现在 action bar 中的 icon 和/或文本被称作action buttons(操作按钮)。安排不下的或不足够重要的操作被隐藏在 action overflow 中。</p>
</blockquote>
<img src="/images/20160616220805.png">
<p>一个有search操作按钮和 action overflow 的 action bar，在 action overflow 里能展现额外的操作。<br>所有的操作按钮和 action overflow 中其他可用的条目都被定义在 menu资源 的 XML 文件中。通过在项目的 res/menu 目录中新增一个 XML 文件来为 ToolBar 添加操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"</span><br><span class="line">      xmlns:app="http://schemas.android.com/apk/res-auto"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item</span><br><span class="line">        android:id="@+id/player_scale_4_3"</span><br><span class="line">        android:title="@string/player_scale_4_3"/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id="@+id/player_scale_16_9"</span><br><span class="line">        android:title="@string/player_scale_16_9"/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id="@+id/player_scale_default"</span><br><span class="line">        android:title="@string/player_scale_default"/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id="@+id/player_Rotation"</span><br><span class="line">        android:icon="@drawable/ic_rotate_right"</span><br><span class="line">        android:title="@string/player_Rotation"</span><br><span class="line">        app:showAsAction="always"/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<p>tips：这里的 showAsAction 属性决定了该 item 是否在 ToolBar 上单独显示，或是只在 action overflow 中显示。因为使用的ToolBar来自 V7 包，这里需要添加自定义命名空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line"></span><br><span class="line">app:showAsAction=<span class="string">"always"</span></span><br></pre></td></tr></table></figure>
<p>在 Activity 的 onCreateOptionsMenu() 方法回调中 inflate 菜单资源从而获取 Menu 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加ToolBar的事件响应"><a href="#添加ToolBar的事件响应" class="headerlink" title="添加ToolBar的事件响应"></a>添加ToolBar的事件响应</h2><blockquote>
<p>当用户按下某一个操作按钮或者 action overflow 中的其他条目，系统将调用 activity 中onOptionsItemSelected()的回调方法。在该方法的实现里面调用MenuItem的getItemId()来判断哪个条目被按下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.player_scale_4_3:</span><br><span class="line">                mVideoView.setDisplayAspectRatio(PLVideoTextureView.ASPECT_RATIO_4_3);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.player_scale_16_9:</span><br><span class="line">                mVideoView.setDisplayAspectRatio(PLVideoTextureView.ASPECT_RATIO_16_9);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.player_scale_default:</span><br><span class="line">                mVideoView.setDisplayAspectRatio(PLVideoTextureView.ASPECT_RATIO_PAVED_PARENT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> R.id.player_Rotation:</span><br><span class="line">                mRotation = (mRotation + <span class="number">90</span>) % <span class="number">360</span>;</span><br><span class="line">                mVideoView.setDisplayOrientation(mRotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                mVideoView.setDisplayAspectRatio(PLVideoTextureView.ASPECT_RATIO_PAVED_PARENT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须super,否则manifest中设置的actionBar返回无效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="为下级-Activity-添加向上按钮"><a href="#为下级-Activity-添加向上按钮" class="headerlink" title="为下级 Activity 添加向上按钮"></a>为下级 Activity 添加向上按钮</h2><p>在不是程序入口的其他所有屏中（activity 不位于主屏时），需要在 action bar 中为用户提供一个导航到逻辑父屏的up button(向上按钮)。</p>
<p>在 manifest 文件中声明父 activity，并在activity中设置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">           android:name=".PlayerModule.PlayerTextureActivity"</span><br><span class="line">           android:configChanges="orientation|keyboardHidden|screenSize"</span><br><span class="line">           android:parentActivityName="com.artharyoung.mdvideo.MainActivity"</span><br><span class="line">           android:screenOrientation="landscape"</span><br><span class="line">           android:theme="@style/MyTheme.FullScreen"&gt;</span><br><span class="line">       &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">       getSupportActionBar().setDisplayHomeAsUpEnabled(true);</span><br></pre></td></tr></table></figure></p>
<p>tips:在onOptionsItemSelected中不能return true,否则这个返回键会不响应。</p>
<h2 id="添加搜索与分享"><a href="#添加搜索与分享" class="headerlink" title="添加搜索与分享"></a>添加搜索与分享</h2><p>在Menu资源文件中添加item:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;item android:id=<span class="string">"@+id/action_search"</span></span><br><span class="line">          android:title=<span class="string">"@string/menu_search"</span></span><br><span class="line">          android:icon=<span class="string">"@android:drawable/ic_menu_search"</span></span><br><span class="line">          app:showAsAction=<span class="string">"ifRoom|collapseActionView"</span></span><br><span class="line">          app:actionViewClass=<span class="string">"android.support.v7.widget.SearchView"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>在 onCreateOptionsMenu 获取SearchView的对象并设置监听事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MenuItem searchItem = menu.findItem(R.id.action_search);</span><br><span class="line">SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Configure the search info and add any event listeners...</span></span><br></pre></td></tr></table></figure></p>
<p>关于分享的设置，请参考另一个帖子<a href="http://artharyoung.github.io/2016/06/04/2016-6-4/">《APP分享功能的实现》</a></p>
<h2 id="沉浸式状态栏的实现"><a href="#沉浸式状态栏的实现" class="headerlink" title="沉浸式状态栏的实现"></a>沉浸式状态栏的实现</h2><p>APP的状态栏随主题变化，在Android 4.4开始引进，在4.4之前是不能自定义状态栏颜色的。实现主要有三个要点：</p>
<ul>
<li>ToolBar高度设置为wrap_content</li>
<li>ToolBar添加属性android:fitsSystemWindows=”true”</li>
<li>父布局添加属性android:fitsSystemWindows=”true”</li>
</ul>
<p>这样可以达到在android 5.0以上系统中状态栏的半透明，如下：<br><img src="/images/20160616220805.jpg"><br>为了兼容API 19的效果，需要在values-v19添加属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- API 19 兼容半透明状态栏 --&gt;</span><br><span class="line">   &lt;style name="AppTheme" parent="@style/BaseAppTheme"&gt;</span><br><span class="line">       &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样，在API 19的机器上状态栏将变为全透明。但是比较坑爹的是，国产手机对系统的更改，使得这样设置并不能达到理想的效果。比如我在小米4 MIUI 7.3的系统上，Android 6.0的机器上状态栏居然全透明了。<br>这时候就不能在style里做兼容了，可以在Activity中设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStatusBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">          getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/training/appbar/index.html" target="_blank" rel="external">《Adding the App Bar》</a><br><a href="http://hukai.me/android-training-course-in-chinese/basics/actionbar/index.html" target="_blank" rel="external">《添加Action Bar》</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Pattern与Matcher进行用户名与手机号校验]]></title>
      <url>http://artharyoung.github.io/2016/06/12/2016-6-12/</url>
      <content type="html"><![CDATA[<p>Pattern|<a href="https://developer.android.com/reference/java/util/regex/Pattern.html" target="_blank" rel="external">Android API</a><br>Matcher|<a href="https://developer.android.com/reference/java/util/regex/Matcher.html" target="_blank" rel="external">Android API</a></p>
<h2 id="UserName校验"><a href="#UserName校验" class="headerlink" title="UserName校验"></a>UserName校验</h2><p>这样的功能需求多用于账号注册，可以通过如下的正则表达式实现支持字母、数字、下划线的6~16位字符账号注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidUserName</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">       Pattern p = Pattern.compile(<span class="string">"(^[a-zA-Z0-9_]&#123;6,16&#125;)"</span>);</span><br><span class="line">       Matcher m = p.matcher(username);</span><br><span class="line">       <span class="keyword">return</span> m.matches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="手机号校验"><a href="#手机号校验" class="headerlink" title="手机号校验"></a>手机号校验</h2><p>手机号校验首先要了解手机号有哪些，以国内的手机号为例：</p>
<blockquote>
<p>移动：134、135、136、137、138、139、150、151、157(TD)、158、159、187、188</p>
<p>联通：130、131、132、152、155、156、185、186</p>
<p>电信：133、153、180、189、（1349卫通）</p>
</blockquote>
<p>编写正则表达式进行实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidMobile</span><span class="params">(String mobile)</span></span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$"</span>);</span><br><span class="line">        Matcher m = p.matcher(mobiles);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上对于手机号的校验非常严格，在Android的Patterns类中封装了手机号校验的正则表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PHONE</span><br><span class="line">        = Pattern.compile(                      <span class="comment">// sdd = space, dot, or dash</span></span><br><span class="line">                <span class="string">"(\\+[0-9]+[\\- \\.]*)?"</span>        <span class="comment">// +&lt;digits&gt;&lt;sdd&gt;*</span></span><br><span class="line">                + <span class="string">"(\\([0-9]+\\)[\\- \\.]*)?"</span>   <span class="comment">// (&lt;digits&gt;)&lt;sdd&gt;*</span></span><br><span class="line">                + <span class="string">"([0-9][0-9\\- \\.]+[0-9])"</span>); <span class="comment">// &lt;digit&gt;&lt;digit|sdd&gt;+&lt;digit&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可见，对于手机号只要求是0~9的数字。使用SDK中的正则表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidMobile</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Patterns.PHONE.matcher(phone).matches();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他字符串校验"><a href="#其他字符串校验" class="headerlink" title="其他字符串校验"></a>其他字符串校验</h2><p>除此之外，Patterns中还封装了Email、IP-address、WEB_URL等正则表达式。</p>
<p>校验Email地址：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidMail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Patterns.EMAIL_ADDRESS.matcher(email).matches();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>校验URL:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidWebUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Patterns.WEB_URL.matcher(url).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/lonelysharer/archive/2012/03/08/2384773.html" target="_blank" rel="external">Java正则表达式：Pattern类和Matcher类</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[APP分享功能的实现]]></title>
      <url>http://artharyoung.github.io/2016/06/04/2016-6-4/</url>
      <content type="html"><![CDATA[<img src="/images/20160531090847.jpg">
<ul>
<li>说起在APP中添加分享功能，也在项目开发中集成过第三方的社会化组件，功能做出来了之后就发现坑其实挺多的，比如APP体积增加3~4MB，微信、微博等社区集成都需要申请appkey等。当然，一般第三方的社会化组件往往不只是集成分享功能，还会集成账号授权登陆等，而系统的分享功能就比较单纯了。这两天学习了一下系统自带的分享功能，写一篇笔记记录一下。<a id="more"></a>
<h2 id="通过Intent向其他应用发送分享内容"><a href="#通过Intent向其他应用发送分享内容" class="headerlink" title="通过Intent向其他应用发送分享内容"></a>通过Intent向其他应用发送分享内容</h2>先看一下发送邮件的Intent：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">"mailto:artharyoungcn@gmail.com"</span>));</span><br><span class="line">intent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"title"</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"desc"</span>);</span><br><span class="line"><span class="keyword">if</span> (intent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果手机上已经安装了邮件的客户端，这个Intent将匹配action直接拉起邮件客户端。</p>
<h3 id="分享文本的Intent："><a href="#分享文本的Intent：" class="headerlink" title="分享文本的Intent："></a>分享文本的Intent：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"send message to someone"</span>);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>一般我们使用的手机上能匹配这个action的app都不止一个，QQ、微信、微博，这些社交类应用自不必说。蓝牙，NFC等一般也都会匹配这个action。所以系统会显示一个对话框供用户选择，并且会提示用户设置默认分享的APP,个人认为这个并没有什么用，因为我们无法保证用户每一次都分享到同一个app.我们可以使用Intent.createChooser()来设置弹出框的标题，并保证每次都弹出选择框，即使设置了默认分享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"send message to someone"</span>);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"实现分享"</span>));</span><br></pre></td></tr></table></figure>
<p>以上只是分享文本，在实际的开发过程中往往还需要分享图片。</p>
<h3 id="数据流分享（这里以图片分享为例）"><a href="#数据流分享（这里以图片分享为例）" class="headerlink" title="数据流分享（这里以图片分享为例）"></a>数据流分享（这里以图片分享为例）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bm = BitmapFactory.decodeResource(getResources(),R.drawable.chrome);</span><br><span class="line">String path = MediaStore.Images.Media.insertImage(getContentResolver(), bm, <span class="string">""</span>, <span class="string">"desc"</span>);</span><br><span class="line"></span><br><span class="line">Uri imageUri = Uri.parse(path);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_STREAM, imageUri);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"实现分享"</span>));</span><br></pre></td></tr></table></figure>
<p>这里需要提供一个供第三方程序访问的Uri,一般有以下几个方案：</p>
<ul>
<li>把数据写到外部存储（SD卡）上，使用Uri.fromFile()创建一个file://形式的Uri。<br>这个形式的Uri并不是所有程序都能处理。</li>
<li>在自己程序文件夹下用MODE_WORLD_READABLE模式使用openFileOutput()把数据写入文件，<br>之后再用getFileStreamPath()返回一个File。用Uri.fromFile()来创建一个file://样式的Uri。</li>
<li>图片，音频，视频等媒体文件可以用scanFile()扫描然后加到系统媒体库（MediaStore）中，<br>onScanCompleted()回调方法会返回一个content://样式的Uri。</li>
<li>图片还可以用insertImage()来加到媒体库(MediaStore)中，然后会返回一个content://样式的Uri。</li>
<li>在ContentProvider中保存数据，给其他APP提供访问权限。</li>
</ul>
<p>这里我们稍微对比下友盟社会化组件的存储方式，在UMImage.class这个类里面可以发现它在SD卡上自己创建了一个缓存文件夹：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getCache</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String var1;</span><br><span class="line">    <span class="keyword">if</span>(DeviceConfig.isSdCardWrittenable()) &#123;</span><br><span class="line">        var1 = Environment.getExternalStorageDirectory().getCanonicalPath();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(<span class="keyword">this</span>.b)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"dirpath is unknow"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var1 = <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File var2 = <span class="keyword">new</span> File(var1 + <span class="string">"/umeng_cache/"</span>);</span><br><span class="line">    <span class="keyword">if</span>(var2 != <span class="keyword">null</span> &amp;&amp; !var2.exists()) &#123;</span><br><span class="line">        var2.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要添加SD卡的读写权限：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在SDCard中创建与删除文件权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt;</span><br><span class="line">&lt;!-- 往SDCard写入数据权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="分享多条数据"><a href="#分享多条数据" class="headerlink" title="分享多条数据"></a>分享多条数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Uri&gt; imageUris = <span class="keyword">new</span> ArrayList&lt;Uri&gt;();</span><br><span class="line">imageUris.add(imageUri); <span class="comment">// Add your image URIs here</span></span><br><span class="line">imageUris.add(imageUri);</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_SEND_MULTIPLE);</span><br><span class="line">intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);</span><br><span class="line">intent.setType(<span class="string">"image/*"</span>);</span><br><span class="line">startActivity(Intent.createChooser(intent, <span class="string">"分享图片"</span>));</span><br></pre></td></tr></table></figure>
<p>这里为了方便仍然使用上面的uri,只不过add了两次。</p>
<p>以上，都是通过给Intent设置一些其他信息：EXTRA_TEXT，EXTRA_STREAM等，并可以设置MIME（多用途互联网邮件扩展）类型。来达到让第三方客户端进行资源匹配的目的。但是，第三方程序需要能够解析他们，如果我们自定义extras，基本是实现不了分享的。我们可以来看一下如何接收其他APP发过来的分享。</p>
<h3 id="接收其他APP的分享内容"><a href="#接收其他APP的分享内容" class="headerlink" title="接收其他APP的分享内容"></a>接收其他APP的分享内容</h3><ul>
<li>在manifest文件中配置filter。比如我们在demo的MainActivity中配置：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name="android.intent.action.SEND" /&gt;</span><br><span class="line">    &lt;category android:name="android.intent.category.DEFAULT" /&gt;</span><br><span class="line">    &lt;data android:mimeType="image/*" /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name="android.intent.action.SEND" /&gt;</span><br><span class="line">    &lt;category android:name="android.intent.category.DEFAULT" /&gt;</span><br><span class="line">    &lt;data android:mimeType="text/plain" /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name="android.intent.action.SEND_MULTIPLE" /&gt;</span><br><span class="line">    &lt;category android:name="android.intent.category.DEFAULT" /&gt;</span><br><span class="line">    &lt;data android:mimeType="image/*" /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>再次运行的时候会发现分享的列表中多了demo这个APP。</p>
<ul>
<li>处理传入的数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">String action = intent.getAction();</span><br><span class="line">String type = intent.getType();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>拿到action和MIME类型，然后就该干嘛干嘛去了~这里需要注意的是，我们不知道用户传进来的是什么，用户也有可能传错了MIME类型,还有可能传进来的数据非常大，比如一张特别大的图片。所以数据不建议放在UI线程中处理。</p>
<h2 id="使用ShareActionProvider分享数据"><a href="#使用ShareActionProvider分享数据" class="headerlink" title="使用ShareActionProvider分享数据"></a>使用ShareActionProvider分享数据</h2><p>ShareActionProvider是在API等级14以后提供的一种分享方式，与上面的分享对比如下：<br><img src="/images/20160531090856.jpg"></p>
<p>可以发现在UI的显示上还是有很大区别的，ShareActionProvider将分享放在在ActionBar上。使用方法需要现在menu菜单中添加item:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;item android:id=<span class="string">"@+id/action_share"</span></span><br><span class="line">      app:showAsAction=<span class="string">"never"</span></span><br><span class="line">      android:title=<span class="string">"@string/action_share"</span></span><br><span class="line">      app:actionProviderClass=<span class="string">"android.support.v7.widget.ShareActionProvider"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在onCreateOptionsMenu回调中获取ShareActionProvider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line"></span><br><span class="line">    MenuItem item = menu.findItem(R.id.action_share);</span><br><span class="line">    mShareActionProvider = (ShareActionProvider) MenuItemCompat.getActionProvider(item);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过mShareActionProvider.setShareIntent(intent)设置需要分享的内容，intent的设置方式与前面是一样的。</p>
<p>这里有个坑需要注意下，我在demo中使用的是AppCompatActivity，是在appcompat-v7包中的，它使用的也是这个包中的ActionBar。在Menu菜单中需要配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:actionProviderClass=<span class="string">"android.support.v7.widget.ShareActionProvider"</span></span><br></pre></td></tr></table></figure></p>
<p>在Activity中import android.support.v7.widget.ShareActionProvider并使用MenuItemCompat.getActionProvider(item)的方式获取ShareActionProvider。<br>若不使用appcompat-v7包中的ActionBar,则Menu菜单中设置如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;item android:id=<span class="string">"@+id/action_share"</span></span><br><span class="line">      android:showAsAction=<span class="string">"ifRoom"</span></span><br><span class="line">      android:title=<span class="string">"Share"</span></span><br><span class="line">      android:actionProviderClass=<span class="string">"android.widget.ShareActionProvider"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后在onCreateOptionsMenu中，通过一下方式获取ShareActionProvider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mShareActionProvider = (ShareActionProvider) item.getActionProvider();</span><br></pre></td></tr></table></figure></p>
<p>然后就可以通过setShareIntent(intent)分享了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用ViewPager + RadioGroup实现图片轮播等图片展示功能]]></title>
      <url>http://artharyoung.github.io/2016/05/21/viewpager-image-display/</url>
      <content type="html"><![CDATA[<p>主要实现如下两个效果：<br><img src="/images/device-2016-05-21-165941.png"><br><a id="more"></a><br><img src="/images/device-2016-05-21-170040.png"></p>
<p><a href="https://github.com/artharyoung/ViewPagerImageDisplay" title="源代码" target="_blank" rel="external">源代码</a></p>
<ul>
<li>tips:对于上面的两种效果，参考过网络上许多实现方法，大多数都是通过自定义控件的各项属性等来实现。<br>个人还是倾向于使用android本身提供的控件来实现这两种效果。</li>
</ul>
<h1 id="知识点小结："><a href="#知识点小结：" class="headerlink" title="知识点小结："></a>知识点小结：</h1><ul>
<li><p>通过复写ViewPagerAdapter的getPageWidth(int position)方法来实现多个item的展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPageWidth</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/<span class="number">3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过获取屏幕参数来动态设置ViewPager的高度来适配phone、pad等不同分辨率的显示效果。（ViewPager无法设置高度wrap_content，只能指定固定高度）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取屏幕像素相关信息</span></span><br><span class="line">DisplayMetrics dm = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据屏幕信息设置ViewPager容器的宽高,为了适配pad和手机</span></span><br><span class="line">mViewPager.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(dm.widthPixels, dm.heightPixels * <span class="number">1</span>/<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>tips:这里注意使用的LayoutParams为ViewPager父布局的属性，比如：父布局为LinearLayout则使用LinearLayout.LayoutParams</p>
<ul>
<li>通过RadioGroup动态添加RadioButton来实现切换图片时“点”的切换。这里有两个小细节需要注意：<br>1、动态添加的RadioButton需要调用setId(int i)手动设置id,否则setOnCheckedChangeListener的时候找不到子View。<br>2、通过setButtonDrawable设置的图片不能居中，始终在View的左边，这是RadioButton源码中onDraw设定的，看到大多数的解决方案都是复写onDraw其实是LayoutParams设置不对，应该使用RadioGroup.LayoutParams然后setMargins实现居中。<a href="http://stackoverflow.com/questions/7905885/margin-set-programmatically-on-radiobutton-not-applied?answertab=active#tab-top" title="stackoverflow" target="_blank" rel="external">stackoverflow</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RadioButton tempButton = <span class="keyword">new</span> RadioButton(<span class="keyword">this</span>);</span><br><span class="line">tempButton.setButtonDrawable(R.drawable.game_banner_dot_normal);</span><br><span class="line"></span><br><span class="line">RadioGroup.LayoutParams childParams = <span class="keyword">new</span> RadioGroup.LayoutParams(</span><br><span class="line">            RadioGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">            RadioGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">childParams.gravity = Gravity.CENTER_HORIZONTAL;</span><br><span class="line">childParams.setMargins((<span class="keyword">int</span>)getResources().getDimension(R.dimen.ui_layout_margin),<span class="number">0</span>,</span><br><span class="line">                    (<span class="keyword">int</span>)getResources().getDimension(R.dimen.ui_layout_margin),<span class="number">0</span>);</span><br><span class="line">tempButton.setId(i);</span><br><span class="line"></span><br><span class="line">mRadioGroup.addView(tempButton,childParams);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android序列化 Parcelable与Serializable]]></title>
      <url>http://artharyoung.github.io/2016/05/18/my-new-post/</url>
      <content type="html"><![CDATA[<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>序列化是为了保存在内存中的各种对象的状态(也就是实例变量，不是方法)，并且可以把保存的对象状态再读出来。即：序列化是一种能比较好的保存对象状态的机制。</p>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>永久性的保存对象，保存对象的字节序列到本地文件中；</li>
<li>通过序列化对象在网络中传递对象；</li>
<li>通过序列化在进程中传递对象；<a id="more"></a>
<h2 id="序列化方法："><a href="#序列化方法：" class="headerlink" title="序列化方法："></a>序列化方法：</h2></li>
<li>实现Serializable接口，JAVA提供的一个序列化接口。它是一个空接口，为对象提供标准的序列化与反序列化操作。</li>
<li>实现Parcelable接口，Google为Android序列化提供的一个接口，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent和Binder传递。</li>
</ul>
<h2 id="差异比较："><a href="#差异比较：" class="headerlink" title="差异比较："></a>差异比较：</h2><ul>
<li>在使用内存时，Parcelable比Serializable性能高。</li>
<li>Serializable在序列化时会产生大量的临时变量，引起频繁的GC。</li>
<li>Parcelable不能使用在要将数据储存在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性，在外界有变化的情况下；</li>
</ul>
<h2 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h2><p>Serializable:<br>在需要序列化的类中实现Sericalizable接口，并添加serialVersionUID。<br>tips:File=&gt;Settings…=&gt;Inspections=&gt;Serialization issues=&gt;Serializable class without ‘serialVersionUID’勾选上。Alt+ Enter自动生成serialVersionUID。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">UserBean userBean = <span class="keyword">new</span> UserBean();</span><br><span class="line">userBean.setAge(<span class="number">24</span>);</span><br><span class="line">userBean.setName(<span class="string">"young"</span>);</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    out.writeObject(userBean);</span><br><span class="line">    out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    UserBean user = (UserBean) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (ClassNotFoundException e1)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Parcelable：<br>在需要序列化的类中实现Parcelable接口。通过writeToParcel将你的对象映射成Parcel对象，再通过createFromParcel将parcel映射成你的对象，也可以将Parcel看成是一个流，通过writeToParcel把对象写到流里面，在通过createFromParcel把对象从流里面读取对象，只不过这个过程需要自己来实现，因此写的顺序和读的顺序必须一致；<br>tips:Ctrl + j 选择自动生成Parcelable相关代码，手动补全相关方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBean</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UserBean</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//顺序与writeToParcel中保持一致，否则反序列化时会错位</span></span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(@NonNull Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;UserBean&gt; CREATOR = <span class="keyword">new</span> Creator&lt;UserBean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBean <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserBean(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserBean[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserBean[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"parcelable"</span>,userBean);</span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line">intent.getParcelableExtra(<span class="string">"parcelable"</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
  
  
</search>
